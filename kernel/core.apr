; The core apricot library

(ns Apricot::Core)

(def raise Kernel/raise)

(def list
  (fn [& args]
    (.to_list args)))

(def concat
  (fn [& args]
    (.to_list (.reduce (.map args | :to_a) [] :+))))

(def defn
  (fn [name args & body]
    (list 'def name (concat (list 'fn name args) body))))
(.add (.macros *ns*) :defn)

(defn defmacro [name args & body]
  (list 'do
        (concat (list 'defn name args) body)
        (list '.add (list '.macros '*ns*) (.name name))
        name))
(.add (.macros *ns*) :defmacro)

(defn array [& args] args)

(defn set [& args]
  (Set. args))

(defn hash [& args]
  (if (.even? (.length args))
    (let [h {}]
      (.each_slice args 2 | #(.store h %1 %2))
      h)
    (raise ArgumentError "hash requires an even number of arguments")))

(defn cons [head tail]
  (.cons (.to_list tail) head))

(defn apply
  ([f x]
   (.apricot_call f & x))
  ([f x & more]
   (.apricot_call f & (cons x (.concat more (.pop more))))))

;; At this point everything is defined that syntax quote requires

(defn identifier [name]
  (.intern Apricot::Identifier name))

(defn symbol [name]
  (.to_sym name))

(defn gensym [[prefix "g"]]
  (identifier (.gensym Apricot prefix)))

(defn require [& files]
  ; (. Kernel require %) does not call the Rubygems custom require for some
  ; reason, so we use this method. (MAIN is the special toplevel object).
  (.each files | #(. MAIN send :require %)))

(defn puts [& args]
  (Kernel/puts (apply str args)))

(def macroexpand Apricot/macroexpand)
(def macroexpand-1 Apricot/macroexpand_1)

; Type predicates

(defn instance? [c x]
  (.is_a? x c))

(defn module? [x]
  (instance? Module x))

(defn class? [x]
  (instance? Class x))

(defn array? [x]
  (instance? Array x))

(defn list? [x]
  (instance? Apricot::List x))

(defn hash? [x]
  (instance? Hash x))

(defn set? [x]
  (instance? Set x))

(defn string? [x]
  (instance? String x))

(defn regexp? [x]
  (instance? Regexp x))

(defn identifier? [x]
  (instance? Apricot::Identifier x))

(defn symbol? [x]
  (instance? Symbol x))

(defn number? [x]
  (instance? Numeric x))

(defn ratio? [x]
  (instance? Rational x))

(defn integer? [x]
  (instance? Integer x))

(defn fixnum? [x]
  (instance? Fixnum x))

(defn bignum? [x]
  (instance? Bignum x))

(defn float? [x]
  (instance? Float x))

(defn complex? [x]
  (instance? Complex x))

(defn range? [x]
  (instance? Range x))

(defn comparable? [x]
  (instance? Comparable x))

(defn enumerable? [x]
  (instance? Enumerable x))

; Collection functions

(defn first [coll]
  (.first coll))

(defn rest [coll]
  (.drop coll 1))

(defn next [coll]
  (let [r (rest coll)]
    (if (.empty? r)
      nil
      r)))

(defn second [coll]
  (first (next coll)))

(defn ffirst [coll]
  (first (first coll)))

(defn nfirst [coll]
  (next (first coll)))

(defn fnext [coll]
  (first (next coll)))

(defn last [coll]
  (.last coll))

(defn butlast [coll]
  (if (empty? coll)
    []
    (.take coll (. (.count coll) - 1))))

(defn nth
  ([coll index]
   (.fetch coll index))
  ([coll index not-found]
   (.fetch coll index not-found)))

(defn count [coll]
  (.count coll))

(defn take [n coll]
  (.take coll n))

(defn drop [n coll]
  (.drop coll n))

(defn empty? [coll]
  (.empty? coll))

(defn reverse [coll]
  (.reverse coll))

(defn map
  ([f coll]
   (.map coll | f))
  ([f coll & colls]
   (.map (.zip coll & colls) | #(apply f %))))

(defn reduce
  ([f coll]
   (.reduce coll | f))
  ([f val coll]
   (.reduce coll val | f)))

(defn contains? [coll val]
  (.include? coll val))

; Hash map functions
(defn get
  ([map key]
   (.fetch map key))
  ([map key not-found]
   (.fetch map key not-found)))

(defn keys [map]
  (.keys map))

(defn vals [map]
  (.values map))

; Basic logic predicates and functions

(defn nil? [x]
  (.nil? x))

(defn true? [x]
  (.equal? x true))

(defn false? [x]
  (.equal? x false))

(defn not [x]
  (if x false true))

; Number predicates and functions

(defn zero? [x]
  (.zero? x))

(defn pos? [x]
  (. x > 0))

(defn neg? [x]
  (. x < 0))

(defn even? [x]
  (.even? x))

(defn odd? [x]
  (.odd? x))

(defn +
  ([] 0)
  ([x] x)
  ([x y] (.+ x y))
  ([x y & more]
   (.reduce more (.+ x y) :+)))

(defn *
  ([] 1)
  ([x] x)
  ([x y] (.* x y))
  ([x y & more]
   (.reduce more (.* x y) :*)))

(defn -
  ([x] (. x -@)) ; Ruby's horribly named -@ method is the negation operator
  ([x y] (.- x y))
  ([x y & more]
   (.reduce more (.- x y) :-)))

(defn /
  ([x] (.quo 1 x))
  ([x y] (.quo x y))
  ([x y & more]
   (.reduce more (.quo x y) :quo)))

(defn quot [num div]
  (.div num div))

(defn rem [num div]
  (.remainder num div))

(defn mod [num div]
  (.modulo num div))

(defn pow [num exp]
  (.** num exp))

(defn int [x]
  (.to_i x))

(defn float [x]
  (.to_f x))

(def ratio Kernel/Rational)

(defn inc [x] (+ x 1))
(defn dec [x] (- x 1))

; Bitwise operations

(defn bit-not [x]
  (. x #|~|)) ; Use arbitrary identifier syntax since ~ is a special char

(defn bit-and
  ([x y] (. x & y))
  ([x y & more]
   (.reduce more (. x & y) | #(. %1 & %2))))

(defn bit-or
  ([x y] (. x | y))
  ([x y & more]
   (.reduce more (. x | y) | #(. %1 | %2))))

(defn bit-xor
  ([x y] (. x ^ y))
  ([x y & more]
   (.reduce more (. x ^ y) | #(. %1 ^ %2))))

(defn bit-and-not
  ([x y] (bit-and x (bit-not y)))
  ([x y & more]
   (.reduce more (bit-and x (bit-not y)) | #(bit-and %1 (bit-not %2)))))

(defn bit-shift-left [x n]
  (. x << n))

(defn bit-shift-right [x n]
  (. x >> n))

(defn bit-clear [x n]
  (bit-and-not x (bit-shift-left 1 n)))

(defn bit-set [x n]
  (bit-or x (bit-shift-left 1 n)))

(defn bit-flip [x n]
  (bit-xor x (bit-shift-left 1 n)))

(defn bit-test [x n]
  (not= 0 (bit-and x (bit-shift-left 1 n))))

; Functional programming functions
(defn complement [f]
  (fn
    ([] (not (f)))
    ([x] (not (f x)))
    ([x y] (not (f x y)))
    ([x y & zs] (not (apply f x y zs)))))

(defn constantly [x]
  (fn [& args] x))

(defn identity [x] x)

; TODO: Stole this from Clojure. It probably isn't as efficient as it could be
; in Apricot.
(defn comp
  ([] identity)
  ([f] f)
  ([f g]
     (fn
       ([] (f (g)))
       ([x] (f (g x)))
       ([x y] (f (g x y)))
       ([x y z] (f (g x y z)))
       ([x y z & args] (f (apply g x y z args)))))
  ([f g h]
     (fn
       ([] (f (g (h))))
       ([x] (f (g (h x))))
       ([x y] (f (g (h x y))))
       ([x y z] (f (g (h x y z))))
       ([x y z & args] (f (g (apply h x y z args))))))
  ([f1 f2 f3 & fs]
    (let [fs (reverse (apply list f1 f2 f3 fs))]
      (fn [& args]
        (loop [ret (apply (first fs) args) fs (next fs)]
          (if fs
            (recur ((first fs) ret) (next fs))
            ret))))))

(defn partial
  ([f] f)
  ([f arg1]
   (fn [& args] (apply f arg1 args)))
  ([f arg1 arg2]
   (fn [& args] (apply f arg1 arg2 args)))
  ([f arg1 arg2 arg3]
   (fn [& args] (apply f arg1 arg2 arg3 args)))
  ([f arg1 arg2 arg3 & more]
   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))

; Useful macros

(defmacro when [test & body]
  `(if ~test (do ~@body)))

(defmacro when-not [test & body]
  `(if ~test nil (do ~@body)))

(defmacro ..
  ([x form]
   `(. ~x ~form))
  ([x form & more]
   `(.. (. ~x ~form) ~@more)))

(defmacro ->
  ([x] x)
  ([x form]
   (if (list? form)
     `(~(first form) ~x ~@(next form))
     (list form x)))
  ([x form & more]
   `(-> (-> ~x ~form) ~@more)))

(defmacro ->>
  ([x] x)
  ([x form]
   (if (list? form)
     `(~(first form) ~@(next form) ~x)
     (list form x)))
  ([x form & more]
   `(->> (->> ~x ~form) ~@more)))

(defmacro if-let [bindings then [else nil]]
  `(let [temp# ~(bindings 1)]
     (if temp#
       (let ~bindings
         ~then)
       ~else)))

(defmacro cond [& clauses]
  (when-not (even? (count clauses))
    (raise ArgumentError "cond requires an even number of forms"))
  (when-not (empty? clauses)
    `(if ~(first clauses)
       ~(second clauses)
       (cond ~@(drop 2 clauses)))))

; (case form when* else?)
;   when = [expr+] expr
;   else = expr
;
; Works like Ruby's case/when syntax (uses the === method).
;
; Example:
; (case x
;   [Array] "x is an array"
;   [String Symbol] "x is a string or symbol"
;   "x is unknown")
(defmacro case [x & forms]
  (let [else (if (odd? (count forms))
               (.pop forms))
        val (gensym "case")
        expand (fn expand [& forms]
                 (if (empty? forms)
                   else
                   `(if (or ~@(map (fn [test] `(. ~test === ~val))
                                   (first forms)))
                      ~(second forms)
                      ~(apply expand (drop 2 forms)))))]
    `(let [~val ~x]
       ~(apply expand forms))))

(defmacro and
  ([] true)
  ([x] x)
  ([x & more]
   `(let [and# ~x]
      (if and# (and ~@more) and#))))

(defmacro or
  ([] false)
  ([x] x)
  ([x & more]
   `(let [or# ~x]
      (if or# or# (or ~@more)))))

(defmacro doto [x & forms]
  (let [gx (gensym "doto")]
    `(let [~gx ~x]
       ~@(map (fn [f]
                (if (list? f)
                  `(~(first f) ~gx ~@(rest f))
                  `(~f ~gx)))
              forms)
       ~gx)))

; Equality and inequality

(defn identical? [x y]
  (.equal? x y))

(defn =
  ([x] true)
  ([x y] (. x == y))
  ([x y & more]
   (and
     (. x == y)
     (.all? more | #(. x == %)))))

(defn not=
  ([x] false)
  ([x y] (. x != y))
  ([x y & more]
   (not (apply = x y more))))

(defn compare [x y]
  (. x <=> y))

(defn >
  ([x] true)
  ([x y] (. x > y))
  ([x y & more]
   (and
     (. x > y)
     (.all? (.each_cons (cons y more) 2) | #(. %1 > %2)))))

(defn <
  ([x] true)
  ([x y] (. x < y))
  ([x y & more]
   (and
     (. x < y)
     (.all? (.each_cons (cons y more) 2) | #(. %1 < %2)))))

(defn >=
  ([x] true)
  ([x y] (. x >= y))
  ([x y & more]
   (and
     (. x >= y)
     (.all? (.each_cons (cons y more) 2) | #(. %1 >= %2)))))

(defn <=
  ([x] true)
  ([x y] (. x <= y))
  ([x y & more]
   (and
     (. x <= y)
     (.all? (.each_cons (cons y more) 2) | #(. %1 <= %2)))))

(defn max
  ([x] x)
  ([x & more]
   (.max (cons x more))))

(defn min
  ([x] x)
  ([x & more]
   (.min (cons x more))))

; Miscellaneous (to be sorted)

(defmacro each [binding & body]
  `(.each ~(last binding)
          | (fn [~(first binding)] ~@body)))

(defmacro while-let [binding & body]
  `(loop []
     (let ~binding
       (when ~(first binding)
         ~@body
         (recur)))))

(defn str
  ([] "")
  ([x] (.apricot_str x))
  ([x & args]
   (.reduce args (.apricot_str x) | #(.concat %1 (.apricot_str %2)))))

; Structs

(defmacro defstruct [name & fields]
  `(def ~name (Struct. ~@(map symbol fields))))

; Macros for defining Ruby classes and methods

(defmacro defmethod [target name & body]
  `(.send ~target :define_method ~(symbol name) | (fn ~name ~@body)))

(defmacro defclass
  ([name]
   `(def ~name (Class.)))
  ([name superclass]
   `(def ~name (Class. ~superclass))))
