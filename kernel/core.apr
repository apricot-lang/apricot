; The core apricot library

(ns Apricot::Core)

(def list
  (fn [& args]
    (.to_list args)))

(def concat
  (fn [& args]
    (.to_list (.reduce (.map args | :to_a) [] :+))))

(def defn
  (fn [name args & body]
    (list 'def name (concat (list 'fn args) body))))
(.add (.macros *ns*) :defn)

(defn defmacro [name args & body]
  (list 'do
        (concat (list 'defn name args) body)
        (list '.add (list '.macros '*ns*) (.name name))
        name))
(.add (.macros *ns*) :defmacro)

(defn identity [x] x)

(defn nil? [x]
  (.nil? x))

(defn true? [x]
  (.equal? x true))

(defn false? [x]
  (.equal? x false))

(defn identical? [x y]
  (.equal? x y))

(defn cons [head tail]
  (.cons tail head))

; Number predicates

(defn zero? [x]
  (.zero? x))

(defn pos? [x]
  (. x > 0))

(defn neg? [x]
  (. x < 0))

(defn even? [x]
  (.even? x))

(defn odd? [x]
  (.odd? x))

(defn inc [x]
  (.succ x))

(defn dec [x]
  (.pred x))

(defn + [& args]
  (.reduce args 0 :+))

(defn * [& args]
  (.reduce args 1 :*))

(defn str [& args]
  (.reduce (.map args | :to_s) "" :+))

(defmacro when [test & body]
  (list 'if test (cons 'do (.to_list body))))

(defmacro when-not [test & body]
  (list 'if test nil (cons 'do (.to_list body))))

(defmacro each [binding & body]
  (list '.each (.last binding) '|
        (concat (list 'fn [(.first binding)]) body)))

(defmacro while-let [binding & body]
  (list 'loop []
        (list 'let binding
              (concat (list 'when (.first binding))
                      body
                      '((recur))))))

(defmacro .. [x form & more]
  (if (.empty? more)
    (list '. x form)
    (concat (list '.. (list '. x form)) more)))

(def puts (. Kernel method :puts))
(def require (. Kernel method :require))
(def macroexpand (. Apricot method :macroexpand))
(def macroexpand-1 (. Apricot method :macroexpand_1))
