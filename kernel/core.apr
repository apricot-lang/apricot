; The core apricot library

(ns Apricot::Core)

(def list
  (fn [& args]
    (.to_list args)))

(def concat
  (fn [& args]
    (.to_list (.reduce (.map args | :to_a) [] :+))))

(def defn
  (fn [name args & body]
    (list 'def name (concat (list 'fn args) body))))
(.add (.macros *ns*) :defn)

(defn defmacro [name args & body]
  (list 'do
        (concat (list 'defn name args) body)
        (list '.add (list '.macros '*ns*) (.name name))
        name))
(.add (.macros *ns*) :defmacro)

(defn array [& args] args)

(defn set [& args]
  (.new Set args))

(defn hash [& args]
  (if (.even? (.length args))
    (let [h {}]
      (.each_slice args 2 | #(.store h %1 %2))
      h)
    (.raise Kernel ArgumentError "hash requires an even number of arguments")))

(defn cons [head tail]
  (.cons (.to_list tail) head))

(defn apply [f x & more]
  (if (.empty? more)
    (.apricot_call f & x)
    (.apricot_call f & (cons x (.concat more (.pop more))))))

;; At this point everything is defined that syntax quote requires

(defn first [coll]
  (.first coll))

(defn rest [coll]
  (.drop coll 1))

(defn last [coll]
  (.last coll))

(defn butlast [coll]
  (if (empty? coll)
    []
    (.take coll (. (.count coll) - 1))))

(defn empty? [coll]
  (.empty? coll))

; Useful macros

(defmacro when [test & body]
  `(if ~test (do ~@body)))

(defmacro when-not [test & body]
  `(if ~test nil (do ~@body)))

(defmacro .. [x form & more]
  (if (empty? more)
    `(. ~x ~form)
    `(.. (. ~x ~form) ~@more)))

; Basic logic predicates and functions

(defn nil? [x]
  (.nil? x))

(defn true? [x]
  (.equal? x true))

(defn false? [x]
  (.equal? x false))

(defn not [x]
  (if x false true))

; Number predicates and functions

(defn zero? [x]
  (.zero? x))

(defn pos? [x]
  (. x > 0))

(defn neg? [x]
  (. x < 0))

(defn even? [x]
  (.even? x))

(defn odd? [x]
  (.odd? x))

(defn + [& args]
  (.reduce args 0 :+))

(defn * [& args]
  (.reduce args 1 :*))

(defn - [x & more]
  (if (empty? more)
    (. x -@) ; Ruby's horribly named -@ method is the negation operator
    (.reduce (.unshift more x) :-)))

(defn / [x & more]
  (if (empty? more)
    (.quo 1 x)
    (.reduce (.unshift more x) :quo)))

(defn inc [x] (+ x 1))
(defn dec [x] (- x 1))

; Equality and inequality

(defn identical? [x y]
  (.equal? x y))

(defn = [x & more]
  (.all? more | #(. x == %)))

(defn not= [x & more]
  (not (apply = x more)))

(defn compare [x y]
  (. x <=> y))

(defn > [x & more]
  (if (empty? more)
    true
    (.. (.unshift more x) (each_cons 2) (all? | #(. %1 > %2)))))

(defn >= [x & more]
  (if (empty? more)
    true
    (.. (.unshift more x) (each_cons 2) (all? | #(. %1 >= %2)))))

(defn < [x & more]
  (if (empty? more)
    true
    (.. (.unshift more x) (each_cons 2) (all? | #(. %1 < %2)))))

(defn <= [x & more]
  (if (empty? more)
    true
    (.. (.unshift more x) (each_cons 2) (all? | #(. %1 <= %2)))))

(defn max [x & more]
  (if (empty? more)
    x
    (.max (.unshift more x))))

(defn min [x & more]
  (if (empty? more)
    x
    (.min (.unshift more x))))

; Miscellaneous (to be sorted)

(defmacro each [binding & body]
  `(.each ~(last binding)
          | (fn [~(first binding)] ~@body)))

(defmacro while-let [binding & body]
  `(loop []
     (let ~binding
       (when ~(first binding)
         ~@body
         (recur)))))

(defn str [& args]
  (.reduce (.map args | :to_s) "" :+))

(defn identity [x] x)

(def puts (. Kernel method :puts))
(def require (. Kernel method :require))
(def macroexpand (. Apricot method :macroexpand))
(def macroexpand-1 (. Apricot method :macroexpand_1))
